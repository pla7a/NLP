One possible limitation with the code itself is that (in statements.py) when checking through the brown corpus to check for verbs that may have occurred, it is extremely slow (by the standards of computing). I improved the computation time by declaring the tags as a global variable (so it is only carried out once on execution of the program) and also used python's set() function to reduce duplicates. However, this still doesn't seem ideal given the sheer size of the corpus. And so, I think a way to improve this would be to somehow use a corpus which incorporates probabilistic tagging and then orders them in their frequency of use in the English language. This would mean that, on average, we have to search less of the corpus in order to get a match (but still have to search through all of it when searching for a word which is not contained within).

Another limitation, this time of the program and not the code itself, is the inability for the system to deal with negated sentences. For example, if I say that "Joe does not like ducks", it responds with "Sorry - not isn't a proper name" because it is only considering the "like ducks" part. I think including a separate case for when the word "not" is encountered before would allow for negated statements (and possibly queries) whilst still maintaining the relative simplicity of the overall system.

Another possible improvement, in the same style of the one above, is that we could incorporate probabilistic parsing in order to reduce the amount of ambiguity encountered within the system. For example, if I say "Joe and John are ducks", and then ask "Who is a duck?", it fails to respond because of there being more than one possible parse available for the reply. I think probabilistic parsing would resolve this even if it meant responding with the incorrect answer in the minority of cases. Even simple probabilistic parsing in the style covered in lectures would result in a likely correct response and if the system wanted to be further improved upon then more sophisticated probabilistic parsing mechanisms could be implemented.
